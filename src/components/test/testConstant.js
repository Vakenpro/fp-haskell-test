export const testsData = [
  {
    id: 0,
    data: [
      {
        id: 1,
        question: `Кто заложил теоретические основы функционального программирования? (несколько вариантов ответа)
        1. Джон фон Нейман
        2. Мозес Шёнфинкель
        3. Хаскелл Карри
        4. Алан Тьюринг`,
        trueAnswerId: [2],
        answers: [
          { id: 1, text: '1,2' },
          { id: 2, text: '2,3' },
          { id: 3, text: '4,2' },
          { id: 4, text: '1,4' },
        ],
      },
      {
        id: 2,
        question: `Функциональное программирование основано на идеях из: (несколько вариантов ответа)
        1. комбинаторной логики
        2. теории графов
        3. лямбда-исчисления
        4. коммутационных схем`,
        trueAnswerId: [1],
        answers: [
          { id: 1, text: '1,3' },
          { id: 2, text: '1,2' },
          { id: 3, text: '3,4' },
          { id: 4, text: '2,4' },
        ],
      },
      {
        id: 3,
        question: 'Какой язык программирования является первым функциональным языком?',
        trueAnswerId: [2],
        answers: [
          { id: 1, text: 'Assembler' },
          { id: 2, text: 'Lisp' },
          { id: 3, text: 'Haskell' },
          { id: 4, text: 'Фортран' },
        ],
      },
      {
        id: 4,
        question: 'Какой пункт не относится к свойствам функциональных языков программирования?',
        trueAnswerId: [1],
        answers: [
          { id: 1, text: 'Понятие переменной' },
          { id: 2, text: 'строгая типизация' },
          { id: 3, text: 'модульность' },
          { id: 4, text: 'функции — это значения' },
        ],
      },
      {
        id: 5,
        question: 'К какой классификации относятся функциональные языки программирования?',
        trueAnswerId: [2],
        answers: [
          { id: 1, text: 'Процедурные' },
          { id: 2, text: 'Непроцедурные' },
        ],
      },
      {
        id: 6,
        question: `Какие типовые задачи традиционно решаются методами функционального программирования?	(несколько вариантов ответа)
        1. Построение математического описания функций
        2. Создание баз данных
        3. Определение формальной семантики языка программирования
        4. Эквивалентная трансформация программ`,
        trueAnswerId: [3],
        answers: [
          { id: 1, text: '1,2,3' },
          { id: 2, text: '2,3,4' },
          { id: 3, text: '1,3,4' },
          { id: 4, text: 'Все верны' },
        ],
      },
      {
        id: 7,
        question: 'Функциональное программирование это –',
        trueAnswerId: [4],
        answers: [
          {
            id: 1,
            text:
              'методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определённого класса, а классы образуют иерархию наследования.',
          },
          {
            id: 2,
            text:
              'парадигма программирования, основанная на идее разделения функциональности для улучшения разбиения программы на модули.',
          },
          {
            id: 3,
            text:
              'стиль объектно-ориентированного программирования, при котором отсутствует понятие класса, а наследование производится путём клонирования существующего экземпляра объекта — прототипа.',
          },
          {
            id: 4,
            text:
              'парадигма программирования, в которой процесс вычисления трактуется как вычисление значений функций в математическом понимании последних',
          },
        ],
      },
      {
        id: 8,
        question: 'Какие принципы не относятся к функциональному программированию?',
        trueAnswerId: [3],
        answers: [
          { id: 1, text: 'Все функции – чистые' },
          { id: 2, text: 'Относительная прозрачность функций' },
          { id: 3, text: 'Инкапсуляция' },
          { id: 4, text: 'Лямбда-исчисления' },
        ],
      },
      {
        id: 9,
        question: `Какие преимущества у функциональных языков? (несколько вариантов ответа)
        1. Декларативный синтаксис
        2. Отсутствие переменных
        3. Строгое соблюдение грамматики
        4. Интенсивное использование динамической памяти`,
        trueAnswerId: [4],
        answers: [
          { id: 1, text: '4,3' },
          { id: 2, text: '4,1' },
          { id: 3, text: '2,3' },
          { id: 4, text: '1,3' },
        ],
      },
      {
        id: 10,
        question: `Какие недостатки у функциональных языков? (несколько вариантов ответа)
        1. Отсутствие “синтаксического сахара”
        2. Интенсивное использование динамической памяти
        3. Сопоставление с образцом
        4. Проблемы переносимости`,
        trueAnswerId: [1],
        answers: [
          { id: 1, text: '1,2,4' },
          { id: 2, text: '1,3,4' },
          { id: 3, text: '2,3,4' },
          { id: 4, text: 'Все верны' },
        ],
      },
    ],
  },
  {
    id: 1,
    data: [
      {
        id: 1,
        question: 'Какая функция отбрасывает из списка n первых элементов?',
        trueAnswerId: [3],
        answers: [
          { id: 1, text: 'init' },
          { id: 2, text: 'take' },
          { id: 3, text: 'drop' },
          { id: 4, text: 'product' },
        ],
      },
      {
        id: 2,
        question: `Выберите, что относится к характеристике кортежа.	 (несколько вариантов ответа)
        1. круглые скобки
        2. гомогенность
        3. тип, не зависящий от размера
        4. гетерогенность
        5. тип, зависящий от размера`,
        trueAnswerId: [2],
        answers: [
          { id: 1, text: '1,2,3' },
          { id: 2, text: '1,4,5' },
          { id: 3, text: '2' },
          { id: 4, text: '2,3,4,5' },
          { id: 5, text: 'Все верны' },
        ],
      },
      {
        id: 3,
        question: 'Успешно ли будут выполнены функции head и tail при передаче им пустого списка?',
        trueAnswerId: [2],
        answers: [
          { id: 1, text: 'да, успешно' },
          { id: 2, text: 'нет, будет вызвана ошибка' },
        ],
      },
      {
        id: 4,
        question: `Что выдаст компилятор при загрузке модуля Demo 
        Test.hs
        module Test (sumIt) where
        sum x y = x + y
        const42 = const 42
        Demo.hs
        module Demo where
        import Test
        f1 = const42 True
        f2 = sumIt 3 4
        `,
        trueAnswerId: [3],
        answers: [
          { id: 1, text: 'Загрузятся модуль Demo и модуль Test' },
          { id: 2, text: 'Модуль Demo загрузится' },
          { id: 3, text: 'Компилятор выдаст ошибку, модуль Test будет загружен, а Demo нет' },
          { id: 4, text: 'Компилятор выдаст ошибку, модуль будет Demo загружен, а Test нет' },
          { id: 5, text: 'Компилятор выдаст ошибку, оба модуля не будут загружены' },
        ],
      },
      {
        id: 5,
        question: 'Укажите, где верно организован список',
        trueAnswerId: [1],
        answers: [
          { id: 1, text: '[1, 2, 3]' },
          { id: 2, text: `('H')` },
          { id: 3, text: '[1; 2; 3]' },
          { id: 4, text: `['aaa']` },
          { id: 5, text: '(1, 2, 3)' },
        ],
      },
      {
        id: 6,
        question: 'Функция, где можно использовать функцию в качестве входного или выходного аргумента – это …',
        trueAnswerId: [3],
        answers: [
          { id: 1, text: 'чистая функция' },
          { id: 2, text: 'анонимная функция' },
          { id: 3, text: 'функция высшего порядка' },
          { id: 4, text: 'строгая функция' },
          { id: 5, text: 'функция низшего порядка' },
        ],
      },
      {
        id: 7,
        question: 'Какая функция возвращает список пар?',
        trueAnswerId: [5],
        answers: [
          { id: 1, text: 'map' },
          { id: 2, text: 'reverseAll' },
          { id: 3, text: 'position' },
          { id: 4, text: 'set' },
          { id: 5, text: 'frequency' },
        ],
      },
      {
        id: 8,
        question: `Укажите, где добавление в список организовано верно. (несколько вариантов ответа)
        1. [1, 2] : 3 : [4]
        2. 1 : [2, 3, 4]
        3. [1, 2] : [3, 4]
        4. [2, 3, 4] : 1
        5. 1 : 2 : 3 : 4 : []`,
        trueAnswerId: [3],
        answers: [
          { id: 1, text: '1,5' },
          { id: 2, text: '1,3,4' },
          { id: 3, text: '2,5' },
          { id: 4, text: '2,4' },
          { id: 5, text: '1,3,5' },
        ],
      },
      {
        id: 9,
        question: `Какие действия можно выполнять над кортежами? 	(несколько вариантов ответа)
        1. формирование кортежа
        2. удаление элемента
        3. извлечение данных
        4. конкатенация
        5. добавление элемента`,
        trueAnswerId: [1, 3],
        answers: [
          { id: 1, text: '1,2,5' },
          { id: 2, text: '2,5' },
          { id: 3, text: '2,3,4' },
          { id: 4, text: '1,3' },
          { id: 5, text: '1,3,4' },
        ],
      },
      {
        id: 10,
        question: 'С помощью чего можно  узнать тип каждого вычисленного результата?',
        trueAnswerId: [4],
        answers: [
          { id: 1, text: ':type' },
          { id: 2, text: ':set t' },
          { id: 3, text: ':t' },
          { id: 4, text: ':set +t' },
          { id: 5, text: ':set type' },
        ],
      },
    ],
  },
  {
    id: 2,
    data: [
      {
        id: 1,
        question: `Какие виды полиморфизма существуют в Haskell?	(несколько вариантов ответа)
        1. Полиморфизм подтипов
        2. Обобщённые алгебраические типы данных
        3. Параметрический полиморфизм
        4. Специальный полиморфизм
        `,
        trueAnswerId: [3],
        answers: [
          { id: 1, text: '1,2' },
          { id: 2, text: '2,3' },
          { id: 3, text: '3,4' },
          { id: 4, text: '1,4' },
        ],
      },
      {
        id: 2,
        question: 'Функция параметрически полиморфна, если она …',
        trueAnswerId: [2],
        answers: [
          { id: 1, text: 'предполагает, что для каждого типа имеется своя собственная реализация.' },
          { id: 2, text: 'может вызываться на произвольном типе данных.' },
          { id: 3, text: 'должна быть реализована в классах-потомках.' },
          { id: 4, text: 'не имеет определения' },
        ],
      },
      {
        id: 3,
        question:
          'Две функции одинаковой арности считаются разными, если существует набор значений их аргументов, на котором они …',
        trueAnswerId: [1],
        answers: [
          { id: 1, text: 'дают разные результирующие значения' },
          { id: 2, text: 'дают одинаковые результирующие значения' },
          { id: 3, text: 'не дают значений' },
          { id: 4, text: 'не имеют смысла' },
        ],
      },
      {
        id: 4,
        question: `К какому классу относится данное определение?
        class класс a where
            (==) :: a -> a -> Bool
            (/=) :: a -> a -> Bool
        `,
        trueAnswerId: [3],
        answers: [
          { id: 1, text: 'Show' },
          { id: 2, text: 'Ord' },
          { id: 3, text: 'Eq' },
          { id: 4, text: 'Ix' },
        ],
      },
      {
        id: 5,
        question: `К какому классу относится данное определение?
        class класс a where
            show :: a -> String	`,
        trueAnswerId: [1],
        answers: [
          { id: 1, text: 'Show' },
          { id: 2, text: `Ord` },
          { id: 3, text: 'Eq' },
          { id: 4, text: `Ix` },
        ],
      },
      {
        id: 6,
        question: 'Определение экземпляра начинается с ключевого слова …',
        trueAnswerId: [2],
        answers: [
          { id: 1, text: 'class' },
          { id: 2, text: 'instance' },
          { id: 3, text: 'Instance' },
          { id: 4, text: 'Class' },
        ],
      },
      {
        id: 7,
        question: 'Экземпляр класса может быть определён …',
        trueAnswerId: [3],
        answers: [
          { id: 1, text: 'в начале кода' },
          { id: 2, text: 'в конце кода' },
          { id: 3, text: 'в любой момент' },
          { id: 4, text: 'после определения класса' },
        ],
      },
      {
        id: 8,
        question: `В отличие от ООП, функциональное программирование характеризуется …`,
        trueAnswerId: [2],
        answers: [
          { id: 1, text: 'слабой связью функции с данными, которыми она оперирует' },
          { id: 2, text: 'тем, что тип данных класса формально составляется из уже существующих' },
          { id: 3, text: 'тем, что типы данных уже определены заранее' },
          { id: 4, text: 'тем, что типы данных не определены заранее' },
        ],
      },
    ],
  },
  {
    id: 3,
    data: [
      {
        id: 1,
        question: `Категории очень легко и естественно визуализируются …`,
        trueAnswerId: [2],
        answers: [
          { id: 1, text: 'В виде графика' },
          { id: 2, text: 'Как ориентированные графы' },
          { id: 3, text: 'В виде коммутационной схемы' },
          { id: 4, text: 'Как объекты' },
        ],
      },
      {
        id: 2,
        question: `Морфизм — это`,
        trueAnswerId: [1],
        answers: [
          { id: 1, text: 'это сохраняющая структуру карта из одной математической структуры в другую того же типа' },
          { id: 2, text: 'категория, в которой объекты представляют собой множества' },
          { id: 3, text: 'отображение множеств' },
          { id: 4, text: 'полиморфная функция' },
        ],
      },
      {
        id: 3,
        question: `В каком модуле присутствует Класс Monad?`,
        trueAnswerId: [1],
        answers: [
          { id: 1, text: 'Prelude' },
          { id: 2, text: 'Monads' },
          { id: 3, text: 'Char' },
          { id: 4, text: 'List' },
        ],
      },
      {
        id: 4,
        question: `Функтор — это		(несколько вариантов ответов)
        1. несортированный тип данных
        2. любой объект, реализующий тайпкласс Functor
        3. базовый строительный блок многих ФП понятий
        4. класс типов
        `,
        trueAnswerId: [3],
        answers: [
          { id: 1, text: '1,3,4' },
          { id: 2, text: '1,2,3' },
          { id: 3, text: '2,3,4' },
          { id: 4, text: '1,2,4' },
        ],
      },
      {
        id: 5,
        question: `Функтор определяет единственный метод`,
        trueAnswerId: [3],
        answers: [
          { id: 1, text: 'Char' },
          { id: 2, text: `Bool` },
          { id: 3, text: 'Map' },
          { id: 4, text: `Func` },
        ],
      },
      {
        id: 6,
        question: `Functor — это встроенный класс с определением функции, подобным —
        1. class Functor f where 
             fmap :: (a -> b) -> f a
        
        2. class Functor f where 
             fmap :: (a -> b) -> f a -> f b
        
        3. class Functor f where 
             fmap :: (b -> a) -> f a -> f b
        
        4. class Functor f where 
             fmap :: (b -> a) -> f b -> f a
        `,
        trueAnswerId: [2],
        answers: [
          { id: 1, text: '1' },
          { id: 2, text: '2' },
          { id: 3, text: '3' },
          { id: 4, text: '4' },
        ],
      },
      {
        id: 7,
        question: `Monoid — это`,
        trueAnswerId: [4],
        answers: [
          { id: 1, text: 'это обычный функтор с некоторыми дополнительными функциями' },
          { id: 2, text: 'концепция высокого уровня реализации полиморфизма' },
          { id: 3, text: 'это встроенный класс с определением функции' },
          { id: 4, text: 'набор функций и операторов, в которых выходные данные не зависят от его входных данных' },
        ],
      },
      {
        id: 8,
        question: `Монада это…  (несколько вариантов ответа)
        1. аппликативный функтор с некоторыми дополнительными функциями
        2. То же, что и моноид
        3. пространство, внутри которого можно производить некоторые, специфичные для данного пространства, действия
        4. все вышеперечисленное
        `,
        trueAnswerId: [2],
        answers: [
          { id: 1, text: '1,2' },
          { id: 2, text: '1,3' },
          { id: 3, text: '2,4' },
          { id: 4, text: '2,3' },
        ],
      },
    ],
  },
  {
    id: 4,
    data: [
      {
        id: 1,
        question: `Комбинаторная логика это…`,
        trueAnswerId: [2],
        answers: [
          {
            id: 1,
            text: 'основанный на четких правилах формальный аппарат оперирования со знаниями определенного вида',
          },
          { id: 2, text: 'это модель вычислений, эквивалентная лямбда-исчислению, но без абстракции.' },
          { id: 3, text: 'формальная система для формализации и анализа понятия вычислимости' },
          { id: 4, text: 'анонимная функция' },
        ],
      },
      {
        id: 2,
        question: `λ-исчисление это…`,
        trueAnswerId: [3],
        answers: [
          {
            id: 1,
            text: 'основанный на четких правилах формальный аппарат оперирования со знаниями определенного вида',
          },
          { id: 2, text: 'это модель вычислений, эквивалентная лямбда-исчислению, но без абстракции.' },
          { id: 3, text: 'формальная система для формализации и анализа понятия вычислимости' },
          { id: 4, text: 'анонимная функция' },
        ],
      },
      {
        id: 3,
        question: `Что является предметом теории комбинаторных алгоритмов?`,
        trueAnswerId: [1],
        answers: [
          { id: 1, text: 'вычисления на дискретных математических структурах ' },
          { id: 2, text: 'вычисления на непрерывных математических структурах' },
          { id: 3, text: 'преобразования непрерывных математических структур' },
          { id: 4, text: 'преобразования дискретных математических структур' },
        ],
      },
      {
        id: 4,
        question: `Какова одна из важных проблем в комбинаторных вычислениях?`,
        trueAnswerId: [2],
        answers: [
          { id: 1, text: 'задача определения объектов, не подлежащих обработке' },
          { id: 2, text: 'задача эффективного представления объектов, подлежащих обработке ' },
          { id: 3, text: 'задача выбора языка программирования ' },
          { id: 4, text: 'переход от десятичной системы исчисления к двоичной' },
        ],
      },
      {
        id: 5,
        question: `Каким образом можно найти оптимальные деревья решений?`,
        trueAnswerId: [1],
        answers: [
          { id: 1, text: 'путем систематического поиска в множестве деревьев решений' },
          { id: 2, text: `путем случайного выбора во множестве деревьев решений` },
          { id: 3, text: 'путем выбора первого дерева во множестве деревьев решений ' },
          { id: 4, text: `путем выбора последнего дерева во множестве деревьев решений` },
        ],
      },
      {
        id: 6,
        question: `Когда имеет практическое значение техника исчерпывающего поиска?`,
        trueAnswerId: [4],
        answers: [
          { id: 1, text: 'только для больших значений n ' },
          { id: 2, text: 'только для четных значений n' },
          { id: 3, text: 'только для нечетных значений n' },
          { id: 4, text: 'только для малых значений n' },
        ],
      },
      {
        id: 7,
        question: `Какие фундаментальные проблемы существуют в анализе алгоритмов? (несколько вариантов ответов)
        1. проблем нет 
        2. поиск свойств, которыми обладает данный алгоритм 
        3. поиск свойств, которыми обладает любой алгоритм, решающий данную проблему 
        4. поиск свойств, которыми обладает данный алгоритм; поиск свойств, которыми должен обладать любой алгоритм, решающий данную проблему
        `,
        trueAnswerId: [4],
        answers: [
          { id: 1, text: '1,3,4' },
          { id: 2, text: '1,2,4' },
          { id: 3, text: '1,2,3' },
          { id: 4, text: '2,3,4' },
        ],
      },
      {
        id: 8,
        question: `Какая разница между двумя вопросами: "Какими свойствами обладает данный алгоритм?" и "Какие свойства должен иметь любой алгоритм, решающий данную проблему?"`,
        trueAnswerId: [3],
        answers: [
          { id: 1, text: 'разницы нет' },
          {
            id: 2,
            text:
              'заключения выводятся на основе изучения существа проблемы по отношению к данному классу алгоритмов, поэтому разницы нет',
          },
          {
            id: 3,
            text:
              'в первом случае алгоритм задан, и заключения выводятся путем изучения свойств, присущих ему. Во втором случае задается проблема и точно определяется структура алгоритма, и заключения выводятся на основе изучения существа проблемы по отношению к данному классу алгоритмов',
          },
          { id: 4, text: 'заключения выводятся на основе свойств данного алгоритма, поэтому разницы нет' },
        ],
      },
    ],
  },
  {
    id: 5,
    data: [
      {
        id: 1,
        question: `Трансляция программы это …`,
        trueAnswerId: [3],
        answers: [
          {
            id: 1,
            text: 'программа, которая переводит текст, написанный на языке программирования, в набор машинных кодов',
          },
          { id: 2, text: 'программа, выполняющая интерпретацию' },
          { id: 3, text: 'программа или техническое средство, выполняющее трансляцию программы.' },
          { id: 4, text: 'построчный анализ, обработка и выполнение исходного кода программы или запроса' },
        ],
      },
      {
        id: 2,
        question: `Транслятор обычно выполняет … (несколько вариантов ответа)
        1. диагностику ошибок
        2. формирует словари идентификаторов
        3. преобразует программу на одном языке программирования в другой
        4. обработку и выполнение исходного кода программы
        `,
        trueAnswerId: [3],
        answers: [
          { id: 1, text: '1,2,4' },
          { id: 2, text: '1,3,4' },
          { id: 3, text: '1,2,3' },
          { id: 4, text: '2,3,4' },
        ],
      },
      {
        id: 3,
        question: `Язык, на котором представлена входная программа, называется …`,
        trueAnswerId: [2],
        answers: [
          { id: 1, text: 'целевым языком' },
          { id: 2, text: 'исходным языком' },
          { id: 3, text: 'формальным языком' },
          { id: 4, text: 'естественным языком' },
        ],
      },
      {
        id: 4,
        question: `Цель трансляции это …`,
        trueAnswerId: [1],
        answers: [
          { id: 1, text: 'преобразование текста с одного языка на язык, понятный адресату' },
          { id: 2, text: 'преобразование поврежденного текста одного языка на язык, понятный адресату' },
          { id: 3, text: 'уменьшение размеров кода по сравнению с исходным' },
          { id: 4, text: 'анализ и поиск ошибок в коде' },
        ],
      },
      {
        id: 5,
        question: `При трансляции компьютерной программы адресатом может быть:         (несколько вариантов ответа)
        1. пользователь
        2. устройство – процессор
        3. программа – интерпретатор
        4. программа – компилятор
        `,
        trueAnswerId: [2],
        answers: [
          { id: 1, text: '1,2' },
          { id: 2, text: `2,3` },
          { id: 3, text: '3,4' },
          { id: 4, text: `1,4` },
        ],
      },
      {
        id: 6,
        question: `Интерпретатор может работать двумя способами:		(несколько вариантов ответа)
        1. читать код и исполнять его сразу
        2. читать исполняемый файл
        3. передавать управление программе
        4. читать код, создавать в памяти промежуточное представление кода и выполнять промежуточное представление кода
        `,
        trueAnswerId: [4],
        answers: [
          { id: 1, text: '1,4' },
          { id: 2, text: '1,2' },
          { id: 3, text: '2,3' },
          { id: 4, text: '1,4' },
        ],
      },
      {
        id: 7,
        question: `Достоинства интерпретаторов по сравнению с компиляторами:     (несколько вариантов ответа)
        1. высокая производительность
        2. возможность работы в интерактивном режиме
        3. обнаружение ошибок синтаксиса на этапе выполнения
        4. отсутствие необходимости перекомпиляции исходного кода после внесения изменений и при переносе кода на другую платформу
        `,
        trueAnswerId: [4],
        answers: [
          { id: 1, text: '1,2' },
          { id: 2, text: '2,3' },
          { id: 3, text: '1,4' },
          { id: 4, text: '2,4' },
        ],
      },
      {
        id: 8,
        question: `Достоинства динамической компиляции по сравнению с компиляцией:`,
        trueAnswerId: [1],
        answers: [
          { id: 1, text: 'отсутствие необходимости перекомпиляции программы при переносе на другую платформу' },
          { id: 2, text: 'меньшие требования к ресурсам' },
          { id: 3, text: 'меньшая сложность реализации' },
          {
            id: 4,
            text: 'скорость работы динамически компилируемых программ близка к скорости работы компилируемых программ',
          },
        ],
      },
    ],
  },
  {
    id: 6,
    data: [
      {
        id: 1,
        question: `Парадигма программирования это …`,
        trueAnswerId: [2],
        answers: [
          {
            id: 1,
            text: 'это система взглядов на явления окружающего мира и представлений о возможных взаимодействиях с ними',
          },
          { id: 2, text: 'идей и понятий, определяющих фундаментальный стиль программирования' },
          { id: 3, text: 'Создание систем искусственного интеллекта' },
          { id: 4, text: 'программирование при помощи функций в математическом их понимании' },
        ],
      },
      {
        id: 2,
        question: `Символический искусственный интеллект — это`,
        trueAnswerId: [1],
        answers: [
          { id: 1, text: 'собирательное название для всех методов исследования искусственного интеллекта' },
          { id: 2, text: 'свойство интеллектуальных систем выполнять творческие функции' },
          { id: 3, text: 'класс методов искусственного интеллекта' },
          { id: 4, text: 'низкоуровневый искусственный интеллект' },
        ],
      },
      {
        id: 3,
        question: `Искусственные Нейронные Сети — это`,
        trueAnswerId: [3],
        answers: [
          { id: 1, text: 'совокупность нейронов головного и спинного мозга центральной нервной системы' },
          {
            id: 2,
            text:
              'вычислительные единицы, способные получать входные данные и применять к ним некоторую математическую функцию',
          },
          { id: 3, text: 'это математические модели, созданные по аналогии с биологическими нейронными сетями.' },
          { id: 4, text: 'способность к обучению и запоминанию на основе опыта' },
        ],
      },
      {
        id: 4,
        question: `Адаптивное взвешивание сигналов между искусственными нейронами достигается благодаря …`,
        trueAnswerId: [1],
        answers: [
          { id: 1, text: 'обучающемуся алгоритму' },
          { id: 2, text: 'исходному набору данных' },
          { id: 3, text: 'условий использования сети' },
          { id: 4, text: 'алгоритму симуляции' },
        ],
      },
      {
        id: 5,
        question: `Термин глубокое обучение используется для описания …`,
        trueAnswerId: [3],
        answers: [
          { id: 1, text: 'условий использования сети' },
          { id: 2, text: `сложности алгоритмов нейронных сетей` },
          { id: 3, text: 'алгоритмов используемых в нейронных сетях' },
          { id: 4, text: `слоев нейронов` },
        ],
      },
      {
        id: 6,
        question: `Теневое обучение это …`,
        trueAnswerId: [1],
        answers: [
          { id: 1, text: 'термин, описывающий глубокое обучение с помощью человека' },
          { id: 2, text: 'совокупность методов машинного обучения' },
          { id: 3, text: 'это многопараметрическая задача нелинейной оптимизации' },
          { id: 4, text: 'обучение за счёт применения решений множества' },
        ],
      },
      {
        id: 7,
        question: `Машинное обучение это`,
        trueAnswerId: [4],
        answers: [
          { id: 1, text: 'термин, описывающий глубокое обучение с помощью человека' },
          { id: 2, text: 'совокупность методов машинного обучения' },
          { id: 3, text: 'это многопараметрическая задача нелинейной оптимизации' },
          { id: 4, text: 'обучение за счёт применения решений множества' },
        ],
      },
      {
        id: 8,
        question: `Различают два типа машинного обучения (несколько вариантов ответа)
        1. Обучение по прецедентам
        2. Адаптивное обучение
        3. Дедуктивное обучение
        4. Глубокое обучение
        `,
        trueAnswerId: [1],
        answers: [
          { id: 1, text: '1,3' },
          { id: 2, text: '1,2' },
          { id: 3, text: '2,3' },
          { id: 4, text: '2,4' },
        ],
      },
    ],
  },
];
